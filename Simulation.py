#Import standard library
import math
from functools import partial, reduce
from typing import Tuple

import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm

from utility import *

# TODO update readme file

# ! The creation of new bodies is boring and tedious

# ! Constants should be more

# TODO merge bodies when they collide

# calculates the gravitational field generated by a mass at a distance
def calc_gravitational_acceleration(mass : float, pos : Vector2D, oth_pos : Vector2D) -> Vector2D:
    distance = calc_distance(pos, oth_pos)
    theta = (oth_pos - pos).angle()
    return Vec2D_from_polar(const.G*mass/(distance**2), theta)

# calcolate the distance of two bodies
def calc_distance(pos1 : Vector2D, pos2 : Vector2D) -> float:
    return (pos1-pos2).mod()

# Calculate the acceleration effect of oth_obj on obj
def add_object_field(sum : Vector2D, oth_obj : Body, obj : Body) -> Vector2D:
    # ! this if to remove the error of .angle() if the vector is a zero
    # ! it should be removed after the implementation of merging
    if oth_obj.pos == obj.pos:
        return sum

    return sum + calc_gravitational_acceleration(mass = oth_obj.mass,
                                                 pos = obj.pos,
                                                 oth_pos = oth_obj.pos)

# Calculate the effect of all other bodies on the singular body
def calculate_object_acceleration(obj : Body, oth_objs : Tuple[Body]) -> Vector2D:
    # * setting add_object_field on to obj
    func_add = partial(add_object_field, obj=obj)
    return reduce(func_add, oth_objs, Vector2D(0, 0))

# Calculate and set the effect of ALL objects on each other
def calculate_objects_accelerations(*all_objs : Tuple[Body]) -> None:
    # * calculate the acceleration for each body
    accelerations = [Vector2D(0, 0) for i in all_objs]
    for i, obj in enumerate(all_objs):
        oth_objs = [oth_obj for oth_obj in all_objs if oth_obj != obj]
        accelerations[i] = calculate_object_acceleration(obj, oth_objs)

    # * after having calculated all accelerations change the position and velocity
    for obj, acc in zip(all_objs, accelerations):
        obj.accelerate(acc)



def main():
    from utility.bodies import Bodies  # ! this is a code smell

    # ! import dt in this file

    test_accuracy(*Bodies[::])

    return None

def test_accuracy(*Bodies : Tuple[Body], interval : int = 1, iterations : int = 365000) -> None:
    print(f"The simulation will last {iterations*interval*864000 /(60*60*24*365):.2e} years")

    errors = {"mechanical_en": np.zeros(iterations + 1),
                "kinetic_en": np.zeros(iterations + 1),
                "potential_en": np.zeros(iterations + 1)}

    for iter in tqdm(range(iterations)):
        mec, kin, pot = energy_error(*Bodies)
        errors["mechanical_en"][iter] = mec
        errors["kinetic_en"][iter] = kin
        errors["potential_en"][iter] = pot

        for _ in range(interval):
            calculate_objects_accelerations(*Bodies)
    else:
        mec, kin, pot = energy_error(*Bodies)
        errors["mechanical_en"][iterations] = mec
        errors["kinetic_en"][iterations] = kin
        errors["potential_en"][iterations] = pot

    x = np.arange(0, iterations +1)
    max_mec_en = max(np.fabs(errors["mechanical_en"]))
    errors["mechanical_en"] /= max_mec_en
    errors["kinetic_en"] /= max_mec_en
    errors["potential_en"] /= max_mec_en

    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(16, 5))

    ax1.plot(x, errors["mechanical_en"])
    ax1.title.set_text("Mechanical Energy")
    ax2.plot(x, errors["kinetic_en"])
    ax2.title.set_text("Kinetic Energy")
    ax3.plot(x, errors["potential_en"])
    ax3.title.set_text("Potential Energy")

    plt.suptitle("Errors in Energy")
    ax1.text(0.9, 0.1, f'Normalized respect to {max_mec_en:.2e}J', horizontalalignment='right', verticalalignment='center', transform=ax1.transAxes, color = "green")
    ax2.text(0.9, 0.1, f'Normalized respect to {max_mec_en:.2e}J', horizontalalignment='right', verticalalignment='center', transform=ax2.transAxes, color = "green")
    ax3.text(0.9, 0.1, f'Normalized respect to {max_mec_en:.2e}J', horizontalalignment='right', verticalalignment='center', transform=ax3.transAxes, color = "green")
    plt.show()

def energy_error(*Bodies):
    kinetic = get_kinetic_err(Bodies)
    potential = get_potential_err(Bodies)
    mechanical = kinetic + potential
    return mechanical, kinetic, potential

def get_kinetic_err(Bodies):
    kinetic = 0
    for body in Bodies:
        kinetic += 1/2 * body.mass * body.vel.mod()**2
    return kinetic

def get_potential_err(Bodies):
    potential = 0
    for body in Bodies:
        for oth_body in Bodies:
            if oth_body == body:
                continue

            potential -= const.G * body.mass * oth_body.mass \
                / calc_distance(body.pos, oth_body.pos)
    return potential

if __name__ == "__main__":
    main()
